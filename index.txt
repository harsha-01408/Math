ALCATRAZ2 - GO GOA GONE
#math #combinatorics #ad-hoc-1 #adhoc

You and 8 friends plan a trip and will pool money together. Some pairs of members have a “cold war”: if one goes, the other won’t. You want to choose a subset of members to maximize the total pooled money, subject to these conflicts.

Input
- One line with 8 space-separated integers: the money each of the 8 members would contribute (members are numbered 1..8 in this order).
- One line with an integer P: the number of conflicting pairs.
- The next P lines each contain two integers u v (1 ≤ u, v ≤ 8), indicating that members u and v cannot both go.

Output
Print a single integer: the maximum total money that can be pooled without selecting any conflicting pair.

Constraints
- All values fit in 32-bit signed integers.

Example
Input:
3 14 5 2 3 4 1 9
4
1 2
2 3
4 5
7 8

Output:
30


XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX


Problem: Lucky Triples

You are given an array a[1..n] of positive integers. Count the number of index triples (i, j, k) such that
  1 ≤ i < j < k ≤ n,
  a[i] divides a[j], and
  a[j] divides a[k].

Print the total number of such triples.

Input
- The first line contains an integer n (1 ≤ n ≤ 2⋅10^5).
- The second line contains n integers a1, a2, …, an (1 ≤ ai ≤ 10^6).

Output
- Print a single integer: the number of triples (i, j, k) with i < j < k, a[i] | a[j], and a[j] | a[k].

Notes
- Use 64-bit integer type for the answer (e.g., long long in C++), as the count can be large.
- Values can repeat; equal values are allowed.

Example 1
Input
4
1 2 2 4

Output
4

Explanation
Valid triples (1-based indices): (1,2,3), (1,2,4), (1,3,4), (2,3,4).

Example 2
Input
6
1 2 3 4 6 12

Output
10


XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

GCD of k-Subsets (Exact)

You are given an array A of N positive integers.
You are also given Q queries. Each query provides two integers k and g.

For each query (k, g), compute the number of size-k subsets of A whose GCD is exactly g.
Output each answer modulo 1,000,000,007.

Input
-----
N
A1 A2 ... AN
Q
k1 g1
k2 g2
...
kQ gQ

Output
------
Q lines, where the i-th line is the answer for query (ki, gi) modulo 1,000,000,007.

Notes
-----
- A subset uses distinct indices; order does not matter.
- If no size-k subset has GCD exactly g, print 0.

Sample Input
------------
5
2 3 4 6 9
4
2 3
2 2
3 1
2 1

Sample Output
-------------
3
3
8
4


XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

Problem: Count x such that f(x) = n

Given an integer n (1 ≤ n ≤ 10^18), find how many positive integers x satisfy f(x) = n, where f is defined as:

f(x) =
- 0,                  if x = 1
- x/2 + f(x/2),       if x is even
- x*(x - 1) / 2,      if x is odd

Task:
- Compute the number of x ≥ 1 such that f(x) = n.
- (Optional) Also output all such x in increasing order.

Input:
- A single integer n.

Output:
- First line: an integer k — the number of valid x.
- Second line (optional if k = 0): k space-separated integers, the values of x in strictly increasing order.

Constraints:
- 1 ≤ n ≤ 10^18

Notes:
- Use 64-bit or wider integer arithmetic as needed.


XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

Problem — Max-Sum Unimodal B (No-Valleys)

You are given an array a[1..n]. Build another array b[1..n] such that:
1) 0 ≤ b[i] ≤ a[i] for every i.
2) There do NOT exist indices j < i < k with b[j] > b[i] < b[k].
   (i.e., b has no “valley”; equivalently, b is nondecreasing up to some peak
   (or plateau) and then nonincreasing — a unimodal shape.)

Goal: Maximize the sum S = b[1] + b[2] + … + b[n].

Constraints
- 1 ≤ n ≤ 1e6
- 1 ≤ a[i] ≤ 1e9

Input Format
- First line: integer n
- Second line: n integers a1 a2 … an

Output Format
- First line: a single integer — the maximum possible sum S.
- Second line: n integers b1 b2 … bn forming one optimal array b.
  (Any one optimal b is accepted.)

Example
Input:
4
5 2 7 3

Output:
14
2 2 7 3

Notes
- Use 64-bit integers for sums.
- The shape constraint forbids any strict “> < >” pattern around any index.


XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

Problem: Minimize g(a, b) with a + b = N

You are given a positive integer N.
Your task is to find ordered pairs of positive integers (a, b) such that:
  1) a + b = N
  2) g(a, b) = gcd(a, b) + lcm(a, b) is minimized.

For each test case, determine:
  • The number of ordered pairs (a, b) for which g(a, b) attains its minimum value.

Input Format
• The first line contains an integer T — the number of test cases.
• Each of the next T lines contains a single integer N.

Output Format
• For each test case, output a single integer — the number of ordered pairs (a, b) such that
  a + b = N and g(a, b) is minimized.

Constraints
• 1 ≤ T ≤ 100
• 2 ≤ N ≤ 10^9

Sample Input
2
6
8

Sample Output
2
2

Explanation (for N = 6)
All ordered pairs (a, b) with a + b = 6 are:
(1,5), (2,4), (3,3), (4,2), (5,1).
The minimum value of g(a,b) = gcd(a,b) + lcm(a,b) occurs for (2,4) and (4,2).
Hence, the answer is 2.


XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

Problem: Minimum Number of Security Groups

You are given an array security where security[i] is the security grade required for the i-th server.

You want to partition all servers into some groups such that:

1. Each group is homogeneous:
   All servers in the same group must have the same security grade.

2. Group sizes are almost equal:
   Let size(G) be the number of servers in group G.
   For any two groups G1 and G2, the absolute difference of their sizes must be at most 1:
       |size(G1) - size(G2)| ≤ 1

3. Every server must belong to exactly one group.

Your task is to determine the minimum possible number of groups that you can form while satisfying the conditions above.

Return this minimum number of groups.


XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

You are given an array A of N integers. You are allowed to perform at most one operation:
Choose any index i and replace A[i] with any integer x such that 1 ≤ x ≤ M.

Your goal is to maximize the GCD of the entire array after performing the operation at most once.
Print the maximum possible GCD.

Input Format:
N M
A[1] A[2] … A[N]

Output Format:
A single integer — the maximum possible GCD.

Constraints:
1 ≤ N, M ≤ 1000
1 ≤ A[i] ≤ 1000

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

Problem

You are given an integer n. Compute the number of valid ways to color an n x 3 grid using three colors: Red (R), Green (G), and Blue (B).

The coloring must satisfy the following constraints:

- Row Constraint: No row can be monochromatic. That is, in each row, the three cells must use at least two different colors. (Forbidden: RRR, GGG, BBB.)
- Column Constraint: No column can be monochromatic. That is, in each column, the n cells must use at least two different colors.

Return the number of valid colorings.

Example 1:

Input: n = 1  
Output: 0  
Explanation: With 1 row, each column has only one cell, so it is trivially monochromatic, violating the column constraint.

Example 2:

Input: n = 2  
Output: 174

Example 3:

Input: n = 3  
Output: 9750

Constraints:

- 1 <= n <= 10^9

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX


You are given a string s consisting of the characters '0', '1', and '!'.

Each '!' can be replaced independently by either '0' or '1'. For a given replacement (i.e., a concrete string), count the total number of subsequences that are "01" or "10".

A subsequence is formed by picking any two positions i < j where s[i] = '0' and s[j] = '1' (for "01"), or s[i] = '1' and s[j] = '0' (for "10").

The total count for a string is count_01 + count_10.

The task is to choose replacements for all '!' such that the minimum possible total count (over all 2^k expansions, where k is the number of '!') is returned, modulo 10^9 + 7.

Example 1:

Input: s = "0!1!" Output: 3 Explanation: The minimum total is 3, as shown in the expansions:
"0010": 3
"0011": 4
"0110": 4
"0111": 3

Constraints:
1 <= s.length <= 10^5
s consists only of '0', '1', and '!'.



Return the answer modulo 10^9 + 7.

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

Make the Array Empty

Given an array of n integers, you can repeatedly perform the following operation:

- Consider m to be the current size of the array.
- You may remove k (1 <= k <= m) elements from the array if the sum of 2 raised to the power of each of these elements equals 2 raised to some integer p (where p is non-negative). That is, you can remove elements with values a1, a2, ..., ak only if:
    2^a1 + 2^a2 + ... + 2^ak = 2^p
  for some integer p >= 0.

Your task is to determine the minimum number of such operations required to remove all elements from the array.

Example:
n = 5, arr = [1, 1, 3, 2, 3]
The array can be emptied in 2 operations:
1) Remove elements at positions 1, 2, and 4 because 2^1 + 2^1 + 2^2 = 2^3.
   Remaining array: [3, 3]
2) Remove the remaining elements because 2^3 + 2^3 = 2^4.
   Array becomes empty.

Hence, the answer is 2.

Function Description:
Complete the function findMinOperations with parameter:
- int arr[n]: an array of integers

Return:
- int: the minimum number of operations required to remove all elements from the array

Constraints:
1 <= n <= 1e5
0 <= arr[i] <= 1e6


XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
