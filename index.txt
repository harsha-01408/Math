ALCATRAZ2 - GO GOA GONE
#math #combinatorics #ad-hoc-1 #adhoc

You and 8 friends plan a trip and will pool money together. Some pairs of members have a “cold war”: if one goes, the other won’t. You want to choose a subset of members to maximize the total pooled money, subject to these conflicts.

Input
- One line with 8 space-separated integers: the money each of the 8 members would contribute (members are numbered 1..8 in this order).
- One line with an integer P: the number of conflicting pairs.
- The next P lines each contain two integers u v (1 ≤ u, v ≤ 8), indicating that members u and v cannot both go.

Output
Print a single integer: the maximum total money that can be pooled without selecting any conflicting pair.

Constraints
- All values fit in 32-bit signed integers.

Example
Input:
3 14 5 2 3 4 1 9
4
1 2
2 3
4 5
7 8

Output:
30


XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX


Problem: Lucky Triples

You are given an array a[1..n] of positive integers. Count the number of index triples (i, j, k) such that
  1 ≤ i < j < k ≤ n,
  a[i] divides a[j], and
  a[j] divides a[k].

Print the total number of such triples.

Input
- The first line contains an integer n (1 ≤ n ≤ 2⋅10^5).
- The second line contains n integers a1, a2, …, an (1 ≤ ai ≤ 10^6).

Output
- Print a single integer: the number of triples (i, j, k) with i < j < k, a[i] | a[j], and a[j] | a[k].

Notes
- Use 64-bit integer type for the answer (e.g., long long in C++), as the count can be large.
- Values can repeat; equal values are allowed.

Example 1
Input
4
1 2 2 4

Output
4

Explanation
Valid triples (1-based indices): (1,2,3), (1,2,4), (1,3,4), (2,3,4).

Example 2
Input
6
1 2 3 4 6 12

Output
10


XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

GCD of k-Subsets (Exact)

You are given an array A of N positive integers.
You are also given Q queries. Each query provides two integers k and g.

For each query (k, g), compute the number of size-k subsets of A whose GCD is exactly g.
Output each answer modulo 1,000,000,007.

Input
-----
N
A1 A2 ... AN
Q
k1 g1
k2 g2
...
kQ gQ

Output
------
Q lines, where the i-th line is the answer for query (ki, gi) modulo 1,000,000,007.

Notes
-----
- A subset uses distinct indices; order does not matter.
- If no size-k subset has GCD exactly g, print 0.

Sample Input
------------
5
2 3 4 6 9
4
2 3
2 2
3 1
2 1

Sample Output
-------------
3
3
8
4


XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
