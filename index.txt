ALCATRAZ2 - GO GOA GONE
#math #combinatorics #ad-hoc-1 #adhoc

You and 8 friends plan a trip and will pool money together. Some pairs of members have a “cold war”: if one goes, the other won’t. You want to choose a subset of members to maximize the total pooled money, subject to these conflicts.

Input
- One line with 8 space-separated integers: the money each of the 8 members would contribute (members are numbered 1..8 in this order).
- One line with an integer P: the number of conflicting pairs.
- The next P lines each contain two integers u v (1 ≤ u, v ≤ 8), indicating that members u and v cannot both go.

Output
Print a single integer: the maximum total money that can be pooled without selecting any conflicting pair.

Constraints
- All values fit in 32-bit signed integers.

Example
Input:
3 14 5 2 3 4 1 9
4
1 2
2 3
4 5
7 8

Output:
30


XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX


Problem: Lucky Triples

You are given an array a[1..n] of positive integers. Count the number of index triples (i, j, k) such that
  1 ≤ i < j < k ≤ n,
  a[i] divides a[j], and
  a[j] divides a[k].

Print the total number of such triples.

Input
- The first line contains an integer n (1 ≤ n ≤ 2⋅10^5).
- The second line contains n integers a1, a2, …, an (1 ≤ ai ≤ 10^6).

Output
- Print a single integer: the number of triples (i, j, k) with i < j < k, a[i] | a[j], and a[j] | a[k].

Notes
- Use 64-bit integer type for the answer (e.g., long long in C++), as the count can be large.
- Values can repeat; equal values are allowed.

Example 1
Input
4
1 2 2 4

Output
4

Explanation
Valid triples (1-based indices): (1,2,3), (1,2,4), (1,3,4), (2,3,4).

Example 2
Input
6
1 2 3 4 6 12

Output
10


XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

GCD of k-Subsets (Exact)

You are given an array A of N positive integers.
You are also given Q queries. Each query provides two integers k and g.

For each query (k, g), compute the number of size-k subsets of A whose GCD is exactly g.
Output each answer modulo 1,000,000,007.

Input
-----
N
A1 A2 ... AN
Q
k1 g1
k2 g2
...
kQ gQ

Output
------
Q lines, where the i-th line is the answer for query (ki, gi) modulo 1,000,000,007.

Notes
-----
- A subset uses distinct indices; order does not matter.
- If no size-k subset has GCD exactly g, print 0.

Sample Input
------------
5
2 3 4 6 9
4
2 3
2 2
3 1
2 1

Sample Output
-------------
3
3
8
4


XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

Problem: Count x such that f(x) = n

Given an integer n (1 ≤ n ≤ 10^18), find how many positive integers x satisfy f(x) = n, where f is defined as:

f(x) =
- 0,                  if x = 1
- x/2 + f(x/2),       if x is even
- x*(x - 1) / 2,      if x is odd

Task:
- Compute the number of x ≥ 1 such that f(x) = n.
- (Optional) Also output all such x in increasing order.

Input:
- A single integer n.

Output:
- First line: an integer k — the number of valid x.
- Second line (optional if k = 0): k space-separated integers, the values of x in strictly increasing order.

Constraints:
- 1 ≤ n ≤ 10^18

Notes:
- Use 64-bit or wider integer arithmetic as needed.


XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

Problem — Max-Sum Unimodal B (No-Valleys)

You are given an array a[1..n]. Build another array b[1..n] such that:
1) 0 ≤ b[i] ≤ a[i] for every i.
2) There do NOT exist indices j < i < k with b[j] > b[i] < b[k].
   (i.e., b has no “valley”; equivalently, b is nondecreasing up to some peak
   (or plateau) and then nonincreasing — a unimodal shape.)

Goal: Maximize the sum S = b[1] + b[2] + … + b[n].

Constraints
- 1 ≤ n ≤ 1e6
- 1 ≤ a[i] ≤ 1e9

Input Format
- First line: integer n
- Second line: n integers a1 a2 … an

Output Format
- First line: a single integer — the maximum possible sum S.
- Second line: n integers b1 b2 … bn forming one optimal array b.
  (Any one optimal b is accepted.)

Example
Input:
4
5 2 7 3

Output:
14
2 2 7 3

Notes
- Use 64-bit integers for sums.
- The shape constraint forbids any strict “> < >” pattern around any index.


XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

Problem: Minimize g(a, b) with a + b = N

You are given a positive integer N.
Your task is to find ordered pairs of positive integers (a, b) such that:
  1) a + b = N
  2) g(a, b) = gcd(a, b) + lcm(a, b) is minimized.

For each test case, determine:
  • The number of ordered pairs (a, b) for which g(a, b) attains its minimum value.

Input Format
• The first line contains an integer T — the number of test cases.
• Each of the next T lines contains a single integer N.

Output Format
• For each test case, output a single integer — the number of ordered pairs (a, b) such that
  a + b = N and g(a, b) is minimized.

Constraints
• 1 ≤ T ≤ 100
• 2 ≤ N ≤ 10^9

Sample Input
2
6
8

Sample Output
2
2

Explanation (for N = 6)
All ordered pairs (a, b) with a + b = 6 are:
(1,5), (2,4), (3,3), (4,2), (5,1).
The minimum value of g(a,b) = gcd(a,b) + lcm(a,b) occurs for (2,4) and (4,2).
Hence, the answer is 2.


XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

Problem: Minimum Number of Security Groups

You are given an array security where security[i] is the security grade required for the i-th server.

You want to partition all servers into some groups such that:

1. Each group is homogeneous:
   All servers in the same group must have the same security grade.

2. Group sizes are almost equal:
   Let size(G) be the number of servers in group G.
   For any two groups G1 and G2, the absolute difference of their sizes must be at most 1:
       |size(G1) - size(G2)| ≤ 1

3. Every server must belong to exactly one group.

Your task is to determine the minimum possible number of groups that you can form while satisfying the conditions above.

Return this minimum number of groups.


XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

You are given an array A of N integers. You are allowed to perform at most one operation:
Choose any index i and replace A[i] with any integer x such that 1 ≤ x ≤ M.

Your goal is to maximize the GCD of the entire array after performing the operation at most once.
Print the maximum possible GCD.

Input Format:
N M
A[1] A[2] … A[N]

Output Format:
A single integer — the maximum possible GCD.

Constraints:
1 ≤ N, M ≤ 1000
1 ≤ A[i] ≤ 1000

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

Problem

You are given an integer n. Compute the number of valid ways to color an n x 3 grid using three colors: Red (R), Green (G), and Blue (B).

The coloring must satisfy the following constraints:

- Row Constraint: No row can be monochromatic. That is, in each row, the three cells must use at least two different colors. (Forbidden: RRR, GGG, BBB.)
- Column Constraint: No column can be monochromatic. That is, in each column, the n cells must use at least two different colors.

Return the number of valid colorings.

Example 1:

Input: n = 1  
Output: 0  
Explanation: With 1 row, each column has only one cell, so it is trivially monochromatic, violating the column constraint.

Example 2:

Input: n = 2  
Output: 174

Example 3:

Input: n = 3  
Output: 9750

Constraints:

- 1 <= n <= 10^9

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX


You are given a string s consisting of the characters '0', '1', and '!'.

Each '!' can be replaced independently by either '0' or '1'. For a given replacement (i.e., a concrete string), count the total number of subsequences that are "01" or "10".

A subsequence is formed by picking any two positions i < j where s[i] = '0' and s[j] = '1' (for "01"), or s[i] = '1' and s[j] = '0' (for "10").

The total count for a string is count_01 + count_10.

The task is to choose replacements for all '!' such that the minimum possible total count (over all 2^k expansions, where k is the number of '!') is returned, modulo 10^9 + 7.

Example 1:

Input: s = "0!1!" Output: 3 Explanation: The minimum total is 3, as shown in the expansions:
"0010": 3
"0011": 4
"0110": 4
"0111": 3

Constraints:
1 <= s.length <= 10^5
s consists only of '0', '1', and '!'.



Return the answer modulo 10^9 + 7.

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

Make the Array Empty

Given an array of n integers, you can repeatedly perform the following operation:

- Consider m to be the current size of the array.
- You may remove k (1 <= k <= m) elements from the array if the sum of 2 raised to the power of each of these elements equals 2 raised to some integer p (where p is non-negative). That is, you can remove elements with values a1, a2, ..., ak only if:
    2^a1 + 2^a2 + ... + 2^ak = 2^p
  for some integer p >= 0.

Your task is to determine the minimum number of such operations required to remove all elements from the array.

Example:
n = 5, arr = [1, 1, 3, 2, 3]
The array can be emptied in 2 operations:
1) Remove elements at positions 1, 2, and 4 because 2^1 + 2^1 + 2^2 = 2^3.
   Remaining array: [3, 3]
2) Remove the remaining elements because 2^3 + 2^3 = 2^4.
   Array becomes empty.

Hence, the answer is 2.

Function Description:
Complete the function findMinOperations with parameter:
- int arr[n]: an array of integers

Return:
- int: the minimum number of operations required to remove all elements from the array

Constraints:
1 <= n <= 1e5
0 <= arr[i] <= 1e6


XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

Count Balanced Subarrays

You are given an array `nums` of length `n`. A subarray is a contiguous part of the array.

A subarray is called balanced if the parity of its sum equals the parity of its LCM (least common multiple), where parity is the value modulo 2.

Return the number of balanced subarrays in `nums`.

 

Example 1:

Input: nums = [1,2,3]

Output: 4

Explanation: The balanced subarrays are [1], [2], [3], [1,2,3] (sum=6 even, LCM=6 even).

Example 2:

Input: nums = [4,5]

Output: 3

Explanation: All subarrays: [4] (even sum, even LCM), [5] (odd, odd), [4,5] (odd sum=9, even LCM=20? Wait, adjust if wrong.

Wait, let's calculate properly: for [4,5]: sum=9 odd, LCM=20 even → not balanced. So if output 2, but I made up.


 

Constraints:

1 <= n <= 10^5
1 <= nums[i] <= 10^9
 

class Solution {
public:
    long long countBalancedSubarrays(vector<int>& nums) {
        
    }
};

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

Gambler's Dice

You are given an n-ary perfect tree with k levels.

You need to mark each node of this tree with a number on a dice (1 to 6) such that the
resulting tree is "Gambler Friendly".

A tree is Gambler Friendly if the following holds:
- For every node marked with a number p (1 <= p <= 6), every adjacent node of the tree
  is marked with a number q such that:
    * p and q are adjacent on a standard dice, and
    * p != q
Note: A number is not adjacent to itself on a dice.

Task:
Calculate the number of different ways to label (paint) all nodes of the tree so that the
tree is Gambler Friendly. Since the number can be very large, output the answer modulo
(10^9 + 7).

Input Format:
Two space-separated integers: n and k

Constraints:
2 <= n <= 10^9
1 <= k <= 10^9

Example:
Input:
3 3
Output:
100663296

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

The best subsequence
Description
You are given an array a of size n and an integer k.
The special value of a subsequence p is equal to Σ_{i=2..k} |p_i - p_{i-1}|, where p_i denotes the ith element of the subsequence p.
Find the minimum special value among all subsequences of array a that have a length of k. If it is not possible to apply the operations (e.g., if k < 2), the special value is 0.
Note: A subsequence is a sequence that can be derived from the given sequence by deleting zero or more elements without changing the order of the remaining elements.

Function Signature
You must complete the solve function.
long long solve(int n, vector<int> a, int k) {
    // Your code goes here
}

Parameters
int n: The size of the array a.
vector<int> a: The elements of the array.
int k: The required length of the subsequence.

Return
A single integer representing the minimum special value.

Input Format
The first line contains a single integer n.
The second line contains n space-separated integers, the elements of array a.
The third line contains a single integer k.

Output Format
Print a single integer representing the minimum special value among all subsequences of array a having length k.

Constraints
1 ≤ n ≤ 10^5
1 ≤ k ≤ min(n, 50)
1 ≤ a_i ≤ 10^6

Example
Sample Input
5
9 5 1 4 9
2

Sample Output
0

Explanation
Given:
N = 5
A = [9, 5, 1, 4, 9]
K = 2
We need to find a subsequence of length 2 with the minimum special value. The special value for a subsequence of length 2, say (p1, p2), is |p2 - p1|.
The subsequence (9, 9) can be formed from the array elements at index 0 and 4. Its special value is |9 - 9| = 0. Since the special value cannot be negative, this is the minimum possible value.

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

Islands
Problem Description
The map contains Islands, named from Island 1 to Island N. For any two islands I and Island J (where I ≠ J), you can go to Island J from Island I only if the value I divides J (i.e., I is a divisor of J).
Given the value for the last island, N, find the number of ways to reach Island N from the first Island, that is, Island 1.
Note: Assume 1-based indexing.

Function Description
Complete the solve function. This function takes the following parameter and returns the required answer.
N: An integer representing the index of the destination island.
The function should return a long integer representing the number of ways to reach Island N from Island 1.
long long solve(int N);

Input Format
The first line contains an integer T, which represents the number of test cases.
For each test case:
The first line contains an integer N denoting the Island to reach.

Output Format
For each test case, print a long integer denoting the number of ways to reach Island N from Island 1.

Constraints
1 ≤ T ≤ 10^6
1 ≤ N ≤ 10^6
Time Limit: 10 sec(s) for each input file
Memory Limit: 256 MB

Example
Sample Input
3
2
4
6

Sample Output
1
2
3

Explanation
The first line indicates the number of test cases T = 3.
The first test case:
Given N = 2.
There exists only 1 way to reach Island 2 from Island 1:
Island 1 → Island 2

The second test case:
Given N = 4.
There exist 2 ways to reach Island 4 from Island 1:
Island 1 → Island 4
Island 1 → Island 2 → Island 4

The third test case:
Given N = 6.
There exist 3 ways to reach Island 6 from Island 1:
Island 1 → Island 6
Island 1 → Island 2 → Island 6
Island 1 → Island 3 → Island 6

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

Chef and Diamonds
Our Chef who was a renouned mathematician has recently got into diamonds' business.

She has accidentally misplaced Q diamonds into a jar which already had N chocolates. She then started wondering about an interesting question as following.

If we pick items one by one at random without replacement, what would be the expected number of picks required to get all diamonds out.

Input:
First line will contain T, number of testcases. Then the testcases follow.
Each testcase contains of a single line of input, two integers N, Q.

Output:
For each testcase, output the answer in a single line.
Your answer is considered correct if its absolute or relative error doesn't exceed 1e-6.

Constraints:
1 <= T <= 1e5
1 <= N <= 1e5
1 <= Q <= 1e5

Sample:
Input:
1
2 2

Output:
3.3333333333

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX


Similar Strings

Chota Pendrive likes to play with strings a lot. For a given string s, he obtains its compressed string in the following way:

- In a single operation, he takes any two consecutive equal characters of s, and removes one of them.
- He keeps doing this operation as long as possible.

The resulting string will be the compressed string of s.
Example: if the initial string is "abaaabb", its compressed form is "abab".

Two strings s and t are said to be similar if their compressed strings are equal.

You have to find the number of ordered pairs of similar strings (s, t) having length at least one and at most N.
Both s and t contain lowercase English alphabet letters.

As the answer could be large, print it modulo 1000000007 (10^9 + 7).

Input Format:
- The first line contains an integer T denoting the number of test cases.
- Each test case contains a single integer N.

Output Format:
- For each test case, print a single integer corresponding to the answer.

Constraints:
1 ≤ T, N ≤ 5000

Sample Input:
2
1
2

Sample Output:
26
754

Explanation:
For N = 1:
s and t will be equal and will contain the same character. There are 26 possibilities.

For N = 2:
Case 1: s = t:
  - length 1: 26 possibilities
  - length 2: 26 * 26 possibilities
Case 2: s = "aa", t = "a": 26 possibilities
Case 3: s = "a", t = "aa": 26 possibilities
Total = 26 + 26*26 + 26 + 26 = 754 ordered pairs.


XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

Problem Statement

A monitor initially displays the number 1. There are N buttons, and the i-th button has a value A[i].
If the i-th button is pressed, the number on the monitor is multiplied by A[i].
Each button can be pressed at most once.

Mars and Mourad win the game if they can display the number M by pressing exactly three buttons.

Task:
Given N, M, and the array A, compute the total number of ways to choose exactly three distinct buttons
(i, j, k) such that:

A[i] * A[j] * A[k] = M

The order of pressing does not matter (i.e., choosing the same three indices in a different order is
considered the same way).

Because the answer can be large, output it modulo 10^9 + 7.

Input Format
- The first line contains an integer N (number of buttons).
- The second line contains an integer M (target number).
- The next N lines each contain an integer A[i].

Output Format
- Print one integer: the number of valid ways modulo 10^9 + 7.

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

