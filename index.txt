ALCATRAZ2 - GO GOA GONE
#math #combinatorics #ad-hoc-1 #adhoc

You and 8 friends plan a trip and will pool money together. Some pairs of members have a “cold war”: if one goes, the other won’t. You want to choose a subset of members to maximize the total pooled money, subject to these conflicts.

Input
- One line with 8 space-separated integers: the money each of the 8 members would contribute (members are numbered 1..8 in this order).
- One line with an integer P: the number of conflicting pairs.
- The next P lines each contain two integers u v (1 ≤ u, v ≤ 8), indicating that members u and v cannot both go.

Output
Print a single integer: the maximum total money that can be pooled without selecting any conflicting pair.

Constraints
- All values fit in 32-bit signed integers.

Example
Input:
3 14 5 2 3 4 1 9
4
1 2
2 3
4 5
7 8

Output:
30


XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX


Problem: Lucky Triples

You are given an array a[1..n] of positive integers. Count the number of index triples (i, j, k) such that
  1 ≤ i < j < k ≤ n,
  a[i] divides a[j], and
  a[j] divides a[k].

Print the total number of such triples.

Input
- The first line contains an integer n (1 ≤ n ≤ 2⋅10^5).
- The second line contains n integers a1, a2, …, an (1 ≤ ai ≤ 10^6).

Output
- Print a single integer: the number of triples (i, j, k) with i < j < k, a[i] | a[j], and a[j] | a[k].

Notes
- Use 64-bit integer type for the answer (e.g., long long in C++), as the count can be large.
- Values can repeat; equal values are allowed.

Example 1
Input
4
1 2 2 4

Output
4

Explanation
Valid triples (1-based indices): (1,2,3), (1,2,4), (1,3,4), (2,3,4).

Example 2
Input
6
1 2 3 4 6 12

Output
10


XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

GCD of k-Subsets (Exact)

You are given an array A of N positive integers.
You are also given Q queries. Each query provides two integers k and g.

For each query (k, g), compute the number of size-k subsets of A whose GCD is exactly g.
Output each answer modulo 1,000,000,007.

Input
-----
N
A1 A2 ... AN
Q
k1 g1
k2 g2
...
kQ gQ

Output
------
Q lines, where the i-th line is the answer for query (ki, gi) modulo 1,000,000,007.

Notes
-----
- A subset uses distinct indices; order does not matter.
- If no size-k subset has GCD exactly g, print 0.

Sample Input
------------
5
2 3 4 6 9
4
2 3
2 2
3 1
2 1

Sample Output
-------------
3
3
8
4


XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

Problem: Count x such that f(x) = n

Given an integer n (1 ≤ n ≤ 10^18), find how many positive integers x satisfy f(x) = n, where f is defined as:

f(x) =
- 0,                  if x = 1
- x/2 + f(x/2),       if x is even
- x*(x - 1) / 2,      if x is odd

Task:
- Compute the number of x ≥ 1 such that f(x) = n.
- (Optional) Also output all such x in increasing order.

Input:
- A single integer n.

Output:
- First line: an integer k — the number of valid x.
- Second line (optional if k = 0): k space-separated integers, the values of x in strictly increasing order.

Constraints:
- 1 ≤ n ≤ 10^18

Notes:
- Use 64-bit or wider integer arithmetic as needed.


XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

Problem — Max-Sum Unimodal B (No-Valleys)

You are given an array a[1..n]. Build another array b[1..n] such that:
1) 0 ≤ b[i] ≤ a[i] for every i.
2) There do NOT exist indices j < i < k with b[j] > b[i] < b[k].
   (i.e., b has no “valley”; equivalently, b is nondecreasing up to some peak
   (or plateau) and then nonincreasing — a unimodal shape.)

Goal: Maximize the sum S = b[1] + b[2] + … + b[n].

Constraints
- 1 ≤ n ≤ 1e6
- 1 ≤ a[i] ≤ 1e9

Input Format
- First line: integer n
- Second line: n integers a1 a2 … an

Output Format
- First line: a single integer — the maximum possible sum S.
- Second line: n integers b1 b2 … bn forming one optimal array b.
  (Any one optimal b is accepted.)

Example
Input:
4
5 2 7 3

Output:
14
2 2 7 3

Notes
- Use 64-bit integers for sums.
- The shape constraint forbids any strict “> < >” pattern around any index.


XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

Problem: Minimize g(a, b) with a + b = N

You are given a positive integer N.
Your task is to find ordered pairs of positive integers (a, b) such that:
  1) a + b = N
  2) g(a, b) = gcd(a, b) + lcm(a, b) is minimized.

For each test case, determine:
  • The number of ordered pairs (a, b) for which g(a, b) attains its minimum value.

Input Format
• The first line contains an integer T — the number of test cases.
• Each of the next T lines contains a single integer N.

Output Format
• For each test case, output a single integer — the number of ordered pairs (a, b) such that
  a + b = N and g(a, b) is minimized.

Constraints
• 1 ≤ T ≤ 100
• 2 ≤ N ≤ 10^9

Sample Input
2
6
8

Sample Output
2
2

Explanation (for N = 6)
All ordered pairs (a, b) with a + b = 6 are:
(1,5), (2,4), (3,3), (4,2), (5,1).
The minimum value of g(a,b) = gcd(a,b) + lcm(a,b) occurs for (2,4) and (4,2).
Hence, the answer is 2.


XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

Problem: Minimum Number of Security Groups

You are given an array security where security[i] is the security grade required for the i-th server.

You want to partition all servers into some groups such that:

1. Each group is homogeneous:
   All servers in the same group must have the same security grade.

2. Group sizes are almost equal:
   Let size(G) be the number of servers in group G.
   For any two groups G1 and G2, the absolute difference of their sizes must be at most 1:
       |size(G1) - size(G2)| ≤ 1

3. Every server must belong to exactly one group.

Your task is to determine the minimum possible number of groups that you can form while satisfying the conditions above.

Return this minimum number of groups.


XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

You are given an array A of N integers. You are allowed to perform at most one operation:
Choose any index i and replace A[i] with any integer x such that 1 ≤ x ≤ M.

Your goal is to maximize the GCD of the entire array after performing the operation at most once.
Print the maximum possible GCD.

Input Format:
N M
A[1] A[2] … A[N]

Output Format:
A single integer — the maximum possible GCD.

Constraints:
1 ≤ N, M ≤ 1000
1 ≤ A[i] ≤ 1000

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
